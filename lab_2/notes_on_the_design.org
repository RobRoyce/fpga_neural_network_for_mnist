* seq definitions file
This file contains many of the constants used throughout the design. It has the
number of registers, the bit-widths, the op codes, etc.

* model uart file
- Level :: 1 (top, but not synthesizezd)
This file contains a bunch of tasks (functions) that, so far as I can tell, are
literally only here for simulation purposes (i.e. it acts like a computer or
device that we might be interested in communicating with from the overall
design). Some of the tasks do nothing, such as tskRxData, which I can't find
reference to in any other modules.

* nexys 3 file
- Level :: 1 (top)
This is the top level module. It's what connects all of the submodules with the
board. Hence, it is responsible for IO from/to the buttons, LED's, switches,
etc.

- USB IO :: nexys <-> pc
 - RsRx (in)
 - RsTx (out)

- Board IO :: nexys <-> user
 - sw :: the 8 board switches
 - btnS :: single-step button
 - btnG :: go button
 - btnR :: reset button

* uart top file
- Level :: 2
This file contains the bulk of the UART functionality.

** Outputs
- o-tx :: transmit out
- o-tx-busy :: notifies receiver
- o-rx-data :: notifies transmitter
- o-rx-valid :: let's transmitter know the data was accepted

** Inputs
- i-rx
- i-tx-data
- i-tx-stb
- clk
- rst

** FiFo
- tfifo-empty
- tfifo-full
- tfifo-out
- tfifo-in
- tfifo-rd
- tfifo-rd-z

** Internal wires/regs
- tx-active
- tx-data
- state

** Functionality
- Check for reset
  - if rst -> (state <- stIdle (== 0))
- Else
- Check state
  - case stIdle (== 0)
    - if i-tx-stb
      - state <- stNib1 (== 1)
      - tx-data <- i-tx-data
  - case stCR (== uart-num-nib + 2)(== seq-dp-width/4 + 2)(== 16/4 + 2)(== 6)
    - if ~tfifo-full
      - state <- idle
    - else default
      - if ~tfifo-full
        - state <- state + 1
	- tx-data <- {tx-data, 4'b0000}

#+BEGIN_SRC verilog
   assign tfifo_rd = ~tfifo_empty & ~tx_active & ~tfifo_rd_z;
   assign tfifo_wr = ~tfifo_full & (state!=stIdle);
#+END_SRC

From the above code, we see that the fifo read bit is set if fifo is not empty
AND transmission is active and the fifo read bit is not in high impedance
state.

The fifo write bit is set if the fifo is not full and we're not idling (i.e. state 0)


* seq rf file
- Level :: 3
This file /appears/ to contain the _register files_ (i.e. R0, R1, R2, and R3),
or at least something to do with them.
** Inputs
- ~i_sel_a~: 2 bits (size of register number)
- ~i_sel_b~: 2 bits
- ~i_wdata~: 16 bits (size of ALU)
- ~i_wstb~:  write stop bit
- ~i_wsel~:  2 bits (size of register number) [select which reg to write to?]
- ~clk~
- ~rst~

** Outputs
- ~o_data_a~: 16 bits (size of ALU)
- ~o_data_b~: 16 bits (size of ALU) [why do we need two data outs?]

** Internal wires/regs
- ~rf~: an array - 4x 16bit registers [these are our R0, R1, R2, and R3]
- ~i~: an integer used for loops




It takes 2 select inputs (~i_sel_a~ and
~b~ both 2 bits wide (register number size)), a write stop bit, a data in
(~i_wdata~ 16 bits wide), write select, clock, and reset. It outputs only 2
bits: ~o_data_a~ and ~o_data_b~.


* seq file
- Level :: 2
This file contains the ALU and register file modules.

** Inputs
- ~i_tx_busy~:
- ~i_inst~:
- ~i_inst_valid~:
- ~clk~
- ~rst~

** Outputs
- ~o_tx_data~:
- ~o_tx_valid~:

** Internal wires/regs
- ~alu_data~:
- ~alu_valid~:
- ~rf_data_a~:
- ~rf_data_b~:
- ~inst_const~: [4 bit] constants (assigned ~i_inst[3:0]~)
- ~inst_ra~: [2 bit] register addr (assigned ~i_inst[1:0]~)
- ~inst_rb~: [2 bit] register addr (assigned ~i_inst[3:2]~)
- ~inst_rc~: [2 bit] register addr (assigned ~i_inst[5:4]~)
- ~inst_op~: [2 bit] operations (assigned ~i_inst[7:6]~)
- ~inst_op_push~: (assigned true if operation == push)
- ~inst_op_send~: (assigned true if operation == send)
- ~inst_op_add~: (assigned true if operation == add)
- ~inst_op_mult~: (assigned true if operation == mult)
- ~rf_wsel~: [2 bit] register number select (= ~inst_ra~ if push, else ~inst_rc~)
- ~rf_wstb~: register file write stop bit (= ~alu_valid~) [normal high?]
- ~alu_valid_in~: (assigned ~i_inst_valid~ & (push | add | mult))

** Internal Modules
- ~seq_rf~: register file module
- ~seq_alu~: alu module

* Assignment Tasks
** Nicer UART Printout
In order to accomplish this, we needed a 32-bit buffer that could hold the 4
bytes being received. We removed the original display function that occured on
every negedge of RX (after the repeat loop). A new task was declared called
~tskRxBuffer~ that processed incoming rxBytes and added them to the
rxBuffer. We explicitly look for newline and carriage return symbols coming
from the rx and operate accordingly. If we get a newline, we do as the
instructions said and print out the last 4 received bytes. Note that this may
need to be changed based on the next part of the assignment (even nicer
uart). As for the carriage return, we haven't figured out what to do when that
occurs. It is slightly odd that we are getting both newline and carriage return
every time we receive a packet of 4 bytes (or maybe it's not weird at
all). Either way, I am currently using the carriage return to reset the
rxBuffer to 0, since it always comes after the newline.

*** TODO figure out how to handle the carriage return, if at all.

** Even Nicer UART Printout
The goal is to expand upon the Nicer UART Printout task above. We need to print
"R0:0003" instead of just "0003", for instance.

*** Requirements
- We need to know which register contains the value (i.e. the top module must
  let the UART know what register it is using to retrieve content).
- The UART must send additional bits indicating the register number, trailed by
  a colon, and finally followed by the value within the register

*** Specification
- The spec says we should modify ~uart_top.v~ and ~nexys3.v~, but does not specify which parts
- We need to make sure this does not mess with the other functionality we already have.
