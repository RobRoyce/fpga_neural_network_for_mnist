* Module - Rounding
** Rounding Implementation #1
*** Code
#+BEGIN_SRC verilog
module rounding(
    input wire [2:0] exponent,
    input wire [3:0] significand,
    input wire fifth_bit,
    output reg [2:0] E,
    output reg [3:0] F
    );
   
   initial
     begin
	E <= 3'b000;
	F <= 4'b0000;
     end
   
   always @(*)
     begin
	if(fifth_bit == 1'b0)
	  begin
	     F <= significand;
	     E <= exponent;
	  end
	else if(significand != 4'b1111)
	  begin
	     F <= significand + 1'b1;
	     E <= exponent;
	  end
	else
	  begin
	     if(exponent != 3'b111)
	       begin
		  F <= 4'b1000;
		  E <= exponent + 1'b1;		 
	       end
	     else
	       begin
		  F <= 4'b1111;
		  E <= 3'b111;
	       end	     
	  end
     end
endmodule
#+END_SRC


* Module - Priority Encoder
** Synopsis
Implementation #1 appears to be the better option. There isn't a large
difference, but it does have a reduced fan-in factor. Everything else
seems to be the same.
** Priority Encoder Implementation #1
*** Code
#+BEGIN_SRC verilog
module priority_encoder(input wire signed [11:0] D, output reg [2:0] exponent);
   always @(D)
     begin
	$display("D: %b", D);
	casex(D)
	  12'b01XX_XXXX_XXXX : exponent <= 3'b111;
	  12'b001X_XXXX_XXXX : exponent <= 3'b110;
	  12'b0001_XXXX_XXXX : exponent <= 3'b101;
	  12'b0000_1XXX_XXXX : exponent <= 3'b100;
	  12'b0000_01XX_XXXX : exponent <= 3'b011;
	  12'b0000_001X_XXXX : exponent <= 3'b010;
	  12'b0000_0001_XXXX : exponent <= 3'b001;
	  12'b0000_0000_XXXX : exponent <= 3'b000;
	  default: begin
	     exponent <= 3'b001;
	  end
	  
	endcase // case (D)
     end // always @ (D)
   
endmodule

#+END_SRC
** Priority Encoder Implementation #2
*** Code
#+BEGIN_SRC verilog
module priority_encoder(input wire signed [11:0] D, output reg [2:0] exponent);
   parameter integer WIDTH = 12;
   integer i;
   
   always @(*) begin
      exponent = 0;
      for(i = 4'd4; i <= 4'd10; i = i+1'b1) begin
	 if(D[i]) exponent = i - 3;
      end
      
   end
   
endmodule
#+END_SRC
